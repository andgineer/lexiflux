<!DOCTYPE html>
<html>
    <head>
        <script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <style>
            body, html {
                height: 100%;
                margin: 0;
                padding: 0;
                display: flex;
                flex-direction: column;
            }

            #words-container {
                flex-grow: 1;
                overflow: hidden; /* Hide overflow instead of scroll */
                padding: 10px;
            }

            .navbar .title-container {
                flex-grow: 1;
                text-align: center;
            }

            #prev-button, #next-button {
                flex-shrink: 0; /* Prevents the buttons from shrinking */
            }

            .text-truncate {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

        </style>
    </head>
    <body>
        {% block content %}{% endblock %}

        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

        <script>
            let wordsArray = {{ words|safe }};
            let totalWords = wordsArray.length;
            let topWord = {{ top_word }};
            let pageNum = {{ page.number }};
            let bookId = {{ book.id }};

            function getLastVisibleWord() {
                let containerRect = wordsContainer.getBoundingClientRect();
                let lastVisibleWordIndex = topWord;

                for (let i = topWord; i < wordsArray.length; i++) {
                    let wordId = 'word-' + i;
                    let wordElement = document.getElementById(wordId);

                    if (wordElement) {
                        let wordRect = wordElement.getBoundingClientRect();
                        if (wordRect.bottom <= containerRect.bottom) {
                            lastVisibleWordIndex = i;
                        } else {
                            break; // Exit the loop when the first invisible word is encountered
                        }
                    } else {
                        break; // Exit the loop if the word element does not exist
                    }
                }
                return lastVisibleWordIndex;
            }


            function getVisibleWordsNum() {
                let lastVisibleWordIndex = getLastVisibleWord();
                return lastVisibleWordIndex - topWord + 1;
            }

            function getPrevViewport() {
                // Search for the topWord where the last visible word is the word before the current topWord
                let targetLastWord = topWord - 1;
                // start with heuristic to narrow down the search: go back by 2 viewports number of words
                let low = Math.max(0, topWord - getVisibleWordsNum() * 2);
                let high = topWord - 1;

                let result = binarySearchForTopWord(low, high, targetLastWord);
                if (result !== -1) {
                    return result;
                }

                // If the heuristic-based search fails, start a new search from the beginning
                result = binarySearchForTopWord(0, high, targetLastWord);
                if (result !== -1) {
                    return result;
                }
                else {
                    // If the search did not find the exact match, shift viewport to the beginning
                    return 0;
                }
            }

            function binarySearchForTopWord(low, high, targetLastWord) {
                while (low < high) {
                    let mid = Math.floor((low + high) / 2);
                    suppressRedraw(wordsContainer);
                    fillContainerWithWords(mid);
                    resumeRedraw(wordsContainer);

                    let lastVisibleWord = getLastVisibleWord();

                    if (lastVisibleWord < targetLastWord) {
                        low = mid + 1;
                    } else if (lastVisibleWord > targetLastWord) {
                        high = mid;
                    } else {
                        // Found the topWord where the last visible word is our targetLastWord
                        return mid;
                    }
                }
                // If the search did not find the exact match, return -1
                return -1;
            }

            function fillContainerWithWords(startWordIndex) {
                // console.log('Filling words:', wordsArray.slice(0, 10));
                // todo: do not clear container if top word is the same
                let existingSpans = wordsContainer.getElementsByClassName('word');
                let existingSpansMap = {};

                // Map existing spans by their IDs
                for (let span of existingSpans) {
                    existingSpansMap[span.id] = span;
                }

                wordsContainer.innerHTML = ''; // Clear the container to reorder spans
                let containerRect = wordsContainer.getBoundingClientRect();

                for (let i = startWordIndex; i < wordsArray.length && i < startWordIndex + totalWords; i++) {
                    let wordId = 'word-' + i;
                    let wordSpan;
                    let isNewSpan = false;

                    if (existingSpansMap[wordId]) {
                        // Reuse existing span
                        wordSpan = existingSpansMap[wordId];
                    } else {
                        // Create a new span
                        wordSpan = document.createElement('span');
                        wordSpan.id = wordId;
                        wordSpan.className = 'word';
                        wordSpan.setAttribute('hx-trigger', 'click');
                        wordSpan.setAttribute('hx-get', '{% url "word" %}?id=' + i);
                        wordSpan.setAttribute('hx-swap', 'outerHTML');
                        wordSpan.textContent = wordsArray[i];
                        isNewSpan = true;
                    }

                    // Temporarily add the word to the container to measure it
                    wordsContainer.appendChild(wordSpan);

                    // If it's a reused span, reprocess it with HTMX
                    if (!isNewSpan) {
                        htmx.process(wordSpan);
                    }

                    // Check if the word fits fully within the container
                    // let wordRect = wordSpan.getBoundingClientRect();
                    // if (wordRect.bottom > containerRect.bottom || wordRect.right > containerRect.right) {
                        // Word does not fully fit, remove it and stop adding more words
                    //    wordsContainer.removeChild(wordSpan);
                    //    break;
                    //}

                    // Add a space after the word
                    wordsContainer.appendChild(document.createTextNode(' '));
                }
            }

            function suppressRedraw(container) {
                container.style.visibility = 'hidden';
            }

            function resumeRedraw(container) {
                container.style.visibility = 'visible';
            }

            function loadPage(pageNumber) {
                fetch('/page?page-num=' + pageNumber)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json(); // Parse the JSON response
                    })
                    .then(data => {
                        document.getElementById('book').innerHTML = data.html;
                        // Update global variables with new data
                        if (data.data) {
                            wordsArray = data.data.words;
                            totalWords = wordsArray.length;
                            topWord = data.data.topWord;
                            pageNum = parseInt(data.data.pageNum);
                            bookId = data.data.bookId;
                            reInitDom();
                            fillContainerWithWords(topWord);
                            htmx.process(wordsContainer);  // Process HTMX attributes in the new HTML
                        } else {
                            console.error('Invalid or missing data in response');
                            console.log("Response data:", data);
                        }
                    })
                    .catch(error => console.error('Error:', error));
            }

            function reportVieportChange() {
                let url = `/viewport?top-word=${topWord}&book-id=${bookId}&page-num=${pageNum}`;
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.text();
                    })
                    .then(data => {
                        console.log('Server response:', data);
                        // Optionally update the UI based on the server's response
                    })
                    .catch(error => console.error('Error:', error));
            }

            document.body.addEventListener('htmx:configRequest', function(event) {
                // Add page and book parameters to all HTMX requests
                event.detail.parameters['page-num'] = pageNum;
                event.detail.parameters['book-id'] = bookId;
                event.detail.parameters['top-word'] = topWord;
            });

            function handlePrevButtonClick() {
                if (topWord === 0) {
                    // Already at the beginning of the page, load the previous page
                    if (pageNum === 1) {
                        // Already at the beginning of the book, do nothing
                        return;
                    }
                    loadPage(pageNum - 1);
                    return;
                }
                topWord = getPrevViewport();
                fillContainerWithWords(topWord);
                reportVieportChange();
            }

            function handleNextButtonClick() {
                let lastWordIndex = getLastVisibleWord();
                console.log('Last word index:', lastWordIndex);
                if (lastWordIndex >= wordsArray.length - 1) {
                    // Last word is already visible, load the next page
                    loadPage(pageNum + 1);
                    return;
                }
                topWord = lastWordIndex + 1;
                reportVieportChange();
                fillContainerWithWords(topWord);
            }

            function reInitDom() {
                // Reattach event listener to the previous button
                let prevButton = document.getElementById('prev-button');
                if (prevButton) {
                    prevButton.removeEventListener('click', handlePrevButtonClick);
                    prevButton.addEventListener('click', handlePrevButtonClick);
                }

                // Reattach event listener to the next button
                let nextButton = document.getElementById('next-button');
                if (nextButton) {
                    nextButton.removeEventListener('click', handleNextButtonClick);
                    nextButton.addEventListener('click', handleNextButtonClick);
                }

                wordsContainer = document.getElementById('words-container');

            // window.addEventListener('resize', function() {
            //    fillContainerWithWords(topWord);
            // );
            }
            reInitDom();
            fillContainerWithWords(topWord);
        </script>

    </body>
</html>
