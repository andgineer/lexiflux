<!DOCTYPE html>
<html>
    <head>
        <script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <style>
            body, html {
                height: 100%;
                margin: 0;
                padding: 0;
                display: flex;
                flex-direction: column;
            }

            #word-container {
                flex-grow: 1;
                overflow: hidden; /* Hide overflow instead of scroll */
                padding: 10px;
            }

            .navbar .title-container {
                flex-grow: 1;
                text-align: center;
            }

            #prev-button, #next-button {
                flex-shrink: 0; /* Prevents the buttons from shrinking */
            }

            .text-truncate {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

        </style>
    </head>
    <body>
        {% block content %}{% endblock %}

        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

        <script>
            let wordsArray = {{ words|safe }};
            let topWord = {{ top_word }};
            let pageNum = {{ page.number }};
            let bookId = {{ book.id }};

            function getLastVisibleWord() {
                let container = document.getElementById('word-container');
                let words = document.querySelectorAll('.word');
                let containerRect = container.getBoundingClientRect();
                let lastVisibleWordIndex = 0;

                for (let i = 0; i < words.length; i++) {
                    let wordRect = words[i].getBoundingClientRect();
                    if (wordRect.bottom <= containerRect.bottom && wordRect.right <= containerRect.right) {
                        lastVisibleWordIndex = i;
                    } else {
                        break; // Exit the loop when the first invisible word is encountered
                    }
                }
                return lastVisibleWordIndex;
            }

            function estimateLineHeightAndWordsPerLine(currentTopWordId) {
                let firstWord = document.getElementById('word-' + currentTopWordId);
                let firstWordRect = firstWord.getBoundingClientRect();
                let words = document.querySelectorAll('.word');
                let wordsPerLine = 0;
                let lineHeight = firstWordRect.height;

                for (let word of words) {
                    let rect = word.getBoundingClientRect();
                    if (rect.top === firstWordRect.top) {
                        wordsPerLine++;
                    } else {
                        break; // Break the loop when the first word of the next line is encountered
                    }
                }
                return { lineHeight, wordsPerLine };
            }

            function getPrevPageTopWord() {
                // Find such previous word, so that the last word of the container is the word before the current top word
                let { lineHeight, wordsPerLine } = estimateLineHeightAndWordsPerLine(topWord);
                let containerHeight = document.getElementById('word-container').clientHeight;
                let maxLines = Math.floor(containerHeight / lineHeight);
                let estimatedWordsInContainer = maxLines * wordsPerLine;

                let low = Math.max(0, topWord - estimatedWordsInContainer);
                let high = topWord;
                let mid;

                while (low < high) {
                    mid = Math.floor((low + high) / 2);
                    if (isLastWordPreviousToCurrentTopWord(mid, topWord, wordsArray.length)) {
                        high = mid;
                    } else {
                        low = mid + 1;
                    }
                }

                return low;
            }

            function isLastWordPreviousToCurrentTopWord(candidateTopWordId, currentTopWordId, totalWords) {
                let container = document.getElementById('word-container');
                suppressRedraw(container);

                fillContainerWithWords(candidateTopWordId, totalWords);
                let lastWordId = getLastVisibleWord();

                resumeRedraw(container);

                return lastWordId === currentTopWordId - 1;
            }

            function fillContainerWithWords(startWordIndex, totalWords) {
                console.log('Filling words:', wordsArray.slice(0, 10));
                let container = document.getElementById('word-container');
                let existingSpans = container.getElementsByClassName('word');
                let existingSpansMap = {};

                // Map existing spans by their IDs
                for (let span of existingSpans) {
                    existingSpansMap[span.id] = span;
                }

                container.innerHTML = ''; // Clear the container to reorder spans
                let containerRect = container.getBoundingClientRect();

                for (let i = startWordIndex; i < totalWords && i < startWordIndex + totalWords; i++) {
                    let wordId = 'word-' + i;
                    let wordSpan;
                    let isNewSpan = false;

                    if (existingSpansMap[wordId]) {
                        // Reuse existing span
                        wordSpan = existingSpansMap[wordId];
                    } else {
                        // Create a new span
                        wordSpan = document.createElement('span');
                        wordSpan.id = wordId;
                        wordSpan.className = 'word';
                        wordSpan.setAttribute('hx-trigger', 'click');
                        wordSpan.setAttribute('hx-get', '{% url "word" %}?id=' + i);
                        wordSpan.setAttribute('hx-swap', 'outerHTML');
                        wordSpan.textContent = wordsArray[i];
                        isNewSpan = true;
                    }

                    // Temporarily add the word to the container to measure it
                    container.appendChild(wordSpan);

                    // If it's a reused span, reprocess it with HTMX
                    if (!isNewSpan) {
                        htmx.process(wordSpan);
                    }

                    // Check if the word fits fully within the container
                    let wordRect = wordSpan.getBoundingClientRect();
                    if (wordRect.bottom > containerRect.bottom || wordRect.right > containerRect.right) {
                        // Word does not fully fit, remove it and stop adding more words
                        container.removeChild(wordSpan);
                        break;
                    }

                    // Add a space after the word
                    container.appendChild(document.createTextNode(' '));
                }
            }

            function suppressRedraw(container) {
                container.style.visibility = 'hidden';
            }

            function resumeRedraw(container) {
                container.style.visibility = 'visible';
            }

            function loadPage(pageNum) {
                fetch('/page?page-num=' + pageNum)
                    .then(response => response.text())
                    .then(data => {
                        document.getElementById('book').innerHTML = data;
                    })
                    .catch(error => console.error('Error:', error));
            }
            function reportVieportChange() {
                let url = `/viewport?top-word=${topWord}&book-id=${bookId}&page-num=${pageNum}`;
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.text();
                    })
                    .then(data => {
                        console.log('Server response:', data);
                        // Optionally update the UI based on the server's response
                    })
                    .catch(error => console.error('Error:', error));
            }

            document.body.addEventListener('htmx:configRequest', function(event) {
                // Add page and book parameters to all HTMX requests
                event.detail.parameters['page-num'] = pageNum;
                event.detail.parameters['book-id'] = bookId;
                event.detail.parameters['top-word'] = topWord;
            });

            document.getElementById('prev-button').addEventListener('click', function() {
                topWord = getPrevPageTopWord();
                fillContainerWithWords(topWord, wordsArray.length);
                reportVieportChange();
            });

            // Event listener for the next button
            document.getElementById('next-button').addEventListener('click', function() {
                let lastWordIndex = getLastVisibleWord();
                if (lastWordIndex >= wordsArray.length - 1) {
                    // Last word is already visible, load the next page
                    loadPage({{ page.number|add:1 }});
                } else {
                    // Shift viewport and report it to the server
                    topWord = lastWordIndex + 1;
                    reportVieportChange();
                    fillContainerWithWords(topWord, wordsArray.length);
                }
            });

            window.addEventListener('resize', function() {
                fillContainerWithWords(topWord, wordsArray.length);
            });

            fillContainerWithWords(topWord, wordsArray.length);
        </script>

    </body>
</html>
