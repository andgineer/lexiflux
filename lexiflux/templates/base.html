<!DOCTYPE html>
<html>
    <head>
        <script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <style>
            body, html {
                height: 100%;
                margin: 0;
                padding: 0;
                display: flex;
                flex-direction: column;
            }

            #words-container {
                flex-grow: 1;
                overflow: hidden; /* Hide overflow instead of scroll */
                padding: 10px;
            }

            .navbar .title-container {
                flex-grow: 1;
                text-align: center;
            }

            #prev-button, #next-button {
                flex-shrink: 0; /* Prevents the buttons from shrinking */
            }

            .text-truncate {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

        </style>
    </head>
    <body>
        {% block content %}{% endblock %}

        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

        <script>
            let debugLogging = true;

            function log(...args) {
                if (debugLogging) {
                    console.log(...args);
                }
            }

            let totalWords;
            let wordSpans;
            let topWord = {{ top_word }};
            let pageNum = {{ page.number }};
            let bookId = {{ book.id }};

            function getLastVisibleWord(filledFromWord) {
                let lastVisibleWordIndex = filledFromWord !== undefined ? filledFromWord : topWord;
                let containerRect = wordsContainer.getBoundingClientRect();

                for (let i = lastVisibleWordIndex; i < totalWords; i++) {
                    let wordId = 'word-' + i;
                    let wordElement = document.getElementById(wordId);

                    if (wordElement) {
                        let wordRect = wordElement.getBoundingClientRect();
                        if (wordRect.bottom <= containerRect.bottom) {
                            lastVisibleWordIndex = i;
                        } else {
                            break; // Exit the loop when the first invisible word is encountered
                        }
                    } else {
                        break; // Exit the loop if the word element does not exist
                    }
                }
                return lastVisibleWordIndex;
            }

            function wordsInViewport() {
                // Count the number of words that fit in the viewport
                let containerRect = wordsContainer.getBoundingClientRect();
                let lastVisibleWordIndex = getLastVisibleWord();
                let visibleWordsNum = lastVisibleWordIndex - topWord + 1;
                log('Visible words:', visibleWordsNum);
                let lastWordElement = document.getElementById('word-' + lastVisibleWordIndex);

                let bottomGapInLines;
                if (lastWordElement) {
                    let lastWordRect = lastWordElement.getBoundingClientRect();
                    let lineHeight = lastWordRect.height;
                    let spaceAtBottom = containerRect.bottom - lastWordRect.bottom;
                    bottomGapInLines = spaceAtBottom / lineHeight;
                }
                if (!lastWordElement || bottomGapInLines > 1.5) {
                    fillContainerWithWords(0);
                    lastVisibleWordIndex = getLastVisibleWord(0);
                    visibleWordsNum = lastVisibleWordIndex + 1;
                    fillContainerWithWords(topWord);
                    log('Visible words after re-fill:', visibleWordsNum);
                }
                return visibleWordsNum === 0 ? 1 : visibleWordsNum;
            }

            function findViewport(targetLastWord) {
                // Search for the such topWord so the last visible word is the targetLastWord.
                // targetLastWord defaults to the word before the current topWord.
                if (targetLastWord === undefined) {
                    targetLastWord = topWord - 1;
                }
                if (topWord === 0) {
                    return 0;  // Already at the beginning of the page
                }
                let high = topWord - 1;  // topWord changed by fillContainerWithWords so fix it there
                suppressRedraw(wordsContainer);
                try {
                    // heuristic to narrow down the search: go back by 2 viewports number of words
                    let low = Math.max(0, topWord - wordsInViewport() * 2);
                    fillContainerWithWords(low);
                    let lastVisibleWord = getLastVisibleWord(low);
                    if (lastVisibleWord === targetLastWord) {
                        return low; // wild guess was correct
                    }
                    else if (lastVisibleWord > targetLastWord) {
                        // If the last visible word is inside the viewport
                        // we should shift the viewport to the left and let the binary search do the rest
                        low = 0;
                    }
                    let viewportTopWord = binarySearchForTopWord(low, high, targetLastWord);
                    fillContainerWithWords(viewportTopWord);
                    if (getLastVisibleWord(viewportTopWord) === targetLastWord) {
                        log('try squeeze more words in the viewport');
                        for (let i = viewportTopWord; i >= 0; i--) {
                            fillContainerWithWords(i);
                            if (getLastVisibleWord(i) === targetLastWord) {
                                viewportTopWord = i;
                            } else {
                                fillContainerWithWords(viewportTopWord);
                                break;
                            }
                        }
                        return viewportTopWord;
                    }
                    else {
                        // If the search did not find the exact match, it couldn't be exactly the last
                        log('shift viewport till the target is visible');
                        for (let i = viewportTopWord; i >= 0; i--) {
                            fillContainerWithWords(i);
                            if (getLastVisibleWord(i) >= targetLastWord) {
                                viewportTopWord = i;
                            } else {
                                fillContainerWithWords(viewportTopWord);
                                break;
                            }
                        }
                        return viewportTopWord;
                    }
                } finally {
                    resumeRedraw(wordsContainer);
                }
            }

            function binarySearchForTopWord(low, high, targetLastWord) {
                log('Searching for topWord:', targetLastWord, `between`, low, high);
                while (low < high) {
                    let mid = Math.floor((low + high) / 2);
                    suppressRedraw(wordsContainer);
                    fillContainerWithWords(mid);
                    resumeRedraw(wordsContainer);

                    let lastVisibleWord = getLastVisibleWord(mid);
                    log('mid:', mid, 'lastVisibleWord:', lastVisibleWord, 'low:', low, 'high:', high);

                    if (lastVisibleWord < targetLastWord) {
                        low = mid + 1;
                    } else if (lastVisibleWord > targetLastWord) {
                        high = mid;
                    } else {
                        return mid;
                    }
                }
                return low;
            }

            function fillContainerWithWords(startWordIndex) {
                topWord = startWordIndex;
                // todo: do not clear container if top word is the same
                wordsContainer.innerHTML = ''; // Clear the container to reorder spans
                let containerRect = wordsContainer.getBoundingClientRect();
                for (let i = startWordIndex; i < wordSpans.length; i++) {
                    wordsContainer.appendChild(wordSpans[i]);
                    // Check if the word fits fully within the container
                    // let wordRect = wordSpan.getBoundingClientRect();
                    // if (wordRect.bottom > containerRect.bottom || wordRect.right > containerRect.right) {
                        // Word does not fully fit, remove it and stop adding more words
                    //    wordsContainer.removeChild(wordSpan);
                    //    break;
                    //}
                    wordsContainer.appendChild(document.createTextNode(' ')); // Add a space after the word
                }
                htmx.process(wordsContainer);
            }

            let redrawSuppressCount = 0;

            function suppressRedraw(container) {
                if (redrawSuppressCount === 0) {
                    container.style.visibility = 'hidden';
                }
                redrawSuppressCount++;
            }

            function resumeRedraw(container) {
                redrawSuppressCount--;
                if (redrawSuppressCount === 0) {
                    container.style.visibility = 'visible';
                } else if (redrawSuppressCount < 0) {
                    console.error('Mismatched calls to suppressRedraw and resumeRedraw');
                    redrawSuppressCount = 0; // Reset to prevent further errors
                }
            }

            function loadPage(pageNumber) {
                return new Promise((resolve, reject) => {
                    fetch('/page?page-num=' + pageNumber)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                            return response.json(); // Parse the JSON response
                        })
                        .then(data => {
                            document.getElementById('book').innerHTML = data.html;
                            // Update global variables with new data
                            if (data.data) {
                                totalWords = data.data.words.length;
                                topWord = data.data.topWord;
                                pageNum = parseInt(data.data.pageNum);
                                bookId = data.data.bookId;

                                wordSpans = data.data.words.map((word, index) => {
                                    let wordSpan = document.createElement('span');
                                    wordSpan.id = 'word-' + index;
                                    wordSpan.className = 'word';
                                    wordSpan.setAttribute('hx-trigger', 'click');
                                    wordSpan.setAttribute('hx-get', '{% url "word" %}?id=' + index);
                                    wordSpan.setAttribute('hx-swap', 'outerHTML');
                                    wordSpan.textContent = word;
                                    return wordSpan;
                                });
                                reInitDom();
                                fillContainerWithWords(topWord);
                                resolve(); // Resolve the promise after updating the DOM
                            } else {
                                console.error('Invalid or missing data in response');
                                log("Response data:", data);
                                reject(new Error('Invalid or missing data in response'));
                            }
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            reject(error); // Reject the promise in case of an error
                        });
                });
            }

            function reportVieportChange() {
                let url = `/viewport?top-word=${topWord}&book-id=${bookId}&page-num=${pageNum}`;
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.text();
                    })
                    .then(data => {
                        // No need to process the server's response
                    })
                    .catch(error => console.error('Error:', error));
            }

            document.body.addEventListener('htmx:configRequest', function(event) {
                // Add page and book parameters to all HTMX requests
                event.detail.parameters['page-num'] = pageNum;
                event.detail.parameters['book-id'] = bookId;
                event.detail.parameters['top-word'] = topWord;
            });

            async function handlePrevButtonClick() {
                if (topWord === 0) {
                    // Already at the beginning of the page, load the previous page
                    if (pageNum === 1) {
                        // Already at the beginning of the book, do nothing
                        return;
                    }
                    await loadPage(pageNum - 1);
                    topWord = totalWords;  // Set topWord to the end of the page to trigger a search for the beginning of the page
                }
                findViewport();
                reportVieportChange();
            }

            function handleNextButtonClick() {
                let lastWordIndex = getLastVisibleWord();
                if (lastWordIndex >= totalWords - 1) {
                    // Last word is already visible, load the next page
                    loadPage(pageNum + 1);
                    return;
                }
                topWord = lastWordIndex + 1;
                reportVieportChange();
                fillContainerWithWords(topWord);
            }

            function reInitDom() {
                // Reattach event listener to the previous button
                let prevButton = document.getElementById('prev-button');
                if (prevButton) {
                    prevButton.removeEventListener('click', handlePrevButtonClick);
                    prevButton.addEventListener('click', handlePrevButtonClick);
                }

                // Reattach event listener to the next button
                let nextButton = document.getElementById('next-button');
                if (nextButton) {
                    nextButton.removeEventListener('click', handleNextButtonClick);
                    nextButton.addEventListener('click', handleNextButtonClick);
                }

                wordsContainer = document.getElementById('words-container');

            // window.addEventListener('resize', function() {
            //    fillContainerWithWords(topWord);
            // );
            }
            document.addEventListener('DOMContentLoaded', function() {
                loadPage(pageNum).then(() => {
                    log('Page loaded successfully.');
                }).catch(error => {
                    console.error('Failed to load page:', error);
                });
            });
        </script>

    </body>
</html>
