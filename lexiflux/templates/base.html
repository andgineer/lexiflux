<!DOCTYPE html>
<html>
    <head>
        <script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <style>
            body, html {
                height: 100%;
                margin: 0;
                padding: 0;
                display: flex;
                flex-direction: column;
            }

            #words-container {
                flex-grow: 1;
                overflow: hidden; /* Hide overflow instead of scroll */
                padding: 10px;
            }

            .navbar .title-container {
                flex-grow: 1;
                text-align: center;
            }

            #prev-button, #next-button {
                flex-shrink: 0; /* Prevents the buttons from shrinking */
            }

            .text-truncate {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

        </style>
    </head>
    <body>
        {% block content %}{% endblock %}

        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

        <script>
            let wordsArray = {{ words|safe }};
            let totalWords = wordsArray.length;
            let topWord = {{ top_word }};
            let pageNum = {{ page.number }};
            let bookId = {{ book.id }};

            function getLastVisibleWord(filledFromWord) {
                let lastVisibleWordIndex = filledFromWord !== undefined ? filledFromWord : topWord;
                let containerRect = wordsContainer.getBoundingClientRect();

                for (let i = lastVisibleWordIndex; i < wordsArray.length; i++) {
                    let wordId = 'word-' + i;
                    let wordElement = document.getElementById(wordId);

                    if (wordElement) {
                        let wordRect = wordElement.getBoundingClientRect();
                        if (wordRect.bottom <= containerRect.bottom) {
                            lastVisibleWordIndex = i;
                        } else {
                            break; // Exit the loop when the first invisible word is encountered
                        }
                    } else {
                        break; // Exit the loop if the word element does not exist
                    }
                }
                return lastVisibleWordIndex;
            }

            function getVisibleWordsNum() {
                let containerRect = wordsContainer.getBoundingClientRect();
                let lastVisibleWordIndex = getLastVisibleWord();
                let visibleWordsNum = lastVisibleWordIndex - topWord + 1;
                console.log('Visible words:', visibleWordsNum);
                let lastWordElement = document.getElementById('word-' + lastVisibleWordIndex);

                let bottomGapInLines;
                if (lastWordElement) {
                    let lastWordRect = lastWordElement.getBoundingClientRect();
                    let lineHeight = lastWordRect.height;
                    let spaceAtBottom = containerRect.bottom - lastWordRect.bottom;
                    bottomGapInLines = spaceAtBottom / lineHeight;
                }
                if (!lastWordElement || bottomGapInLines > 1.5) {
                    fillContainerWithWords(0);
                    lastVisibleWordIndex = getLastVisibleWord(0);
                    visibleWordsNum = lastVisibleWordIndex + 1;
                    fillContainerWithWords(topWord);
                    console.log('Visible words after re-fill:', visibleWordsNum);
                }
                return visibleWordsNum;
            }

            function findViewportStart(targetLastWord) {
                // Search for the topWord where the last visible word is the word before the current topWord
                if (targetLastWord === undefined) {
                    targetLastWord = topWord - 1;
                }
                let high = topWord - 1;

                // start with heuristic to narrow down the search: go back by 2 viewports number of words
                let result = binarySearchForTopWord(Math.max(0, topWord - getVisibleWordsNum() * 2), high, targetLastWord);
                if (result === -1) {
                    // If the heuristic-based search fails, start a search from the beginning
                    result = binarySearchForTopWord(0, high, targetLastWord);
                }
                if (result !== -1) {
                    // try squeeze more words in the viewport
                    for (let i = result; i >= 0; i--) {
                        suppressRedraw(wordsContainer);
                        fillContainerWithWords(i);
                        resumeRedraw(wordsContainer);
                        if (getLastVisibleWord(i) === targetLastWord) {
                            result = i;
                        } else {
                            break;
                        }
                    }
                    return result;
                }
                else {
                    // If the search did not find the exact match, shift viewport to the beginning
                    fillContainerWithWords(0)
                    return 0;
                }
            }

            function binarySearchForTopWord(low, high, targetLastWord) {
                console.log('Searching for topWord:', targetLastWord, `between`, low, high);
                while (low < high) {
                    let mid = Math.floor((low + high) / 2);
                    suppressRedraw(wordsContainer);
                    fillContainerWithWords(mid);
                    resumeRedraw(wordsContainer);

                    let lastVisibleWord = getLastVisibleWord(mid);
                    console.log('mid:', mid, 'lastVisibleWord:', lastVisibleWord, 'low:', low, 'high:', high);

                    if (lastVisibleWord < targetLastWord) {
                        low = mid + 1;
                    } else if (lastVisibleWord > targetLastWord) {
                        high = mid;
                    } else {
                        return mid;
                    }
                }
                fillContainerWithWords(low);
                if (getLastVisibleWord(low) === targetLastWord)
                    return low;
                else
                    return -1;
            }

            function fillContainerWithWords(startWordIndex) {
                // console.log('Filling words:', wordsArray.slice(0, 10));
                // todo: do not clear container if top word is the same
                let existingSpans = wordsContainer.getElementsByClassName('word');
                let existingSpansMap = {};

                // Map existing spans by their IDs
                for (let span of existingSpans) {
                    existingSpansMap[span.id] = span;
                }

                wordsContainer.innerHTML = ''; // Clear the container to reorder spans
                let containerRect = wordsContainer.getBoundingClientRect();

                for (let i = startWordIndex; i < wordsArray.length && i < startWordIndex + totalWords; i++) {
                    let wordId = 'word-' + i;
                    let wordSpan;
                    let isNewSpan = false;

                    if (existingSpansMap[wordId]) {
                        // Reuse existing span
                        wordSpan = existingSpansMap[wordId];
                    } else {
                        // Create a new span
                        wordSpan = document.createElement('span');
                        wordSpan.id = wordId;
                        wordSpan.className = 'word';
                        wordSpan.setAttribute('hx-trigger', 'click');
                        wordSpan.setAttribute('hx-get', '{% url "word" %}?id=' + i);
                        wordSpan.setAttribute('hx-swap', 'outerHTML');
                        wordSpan.textContent = wordsArray[i];
                        isNewSpan = true;
                    }

                    // Temporarily add the word to the container to measure it
                    wordsContainer.appendChild(wordSpan);

                    // Check if the word fits fully within the container
                    // let wordRect = wordSpan.getBoundingClientRect();
                    // if (wordRect.bottom > containerRect.bottom || wordRect.right > containerRect.right) {
                        // Word does not fully fit, remove it and stop adding more words
                    //    wordsContainer.removeChild(wordSpan);
                    //    break;
                    //}

                    // Add a space after the word
                    wordsContainer.appendChild(document.createTextNode(' '));
                }
                htmx.process(wordsContainer);
            }

            function suppressRedraw(container) {
                container.style.visibility = 'hidden';
            }

            function resumeRedraw(container) {
                container.style.visibility = 'visible';
            }

            function loadPage(pageNumber) {
                return new Promise((resolve, reject) => {
                    fetch('/page?page-num=' + pageNumber)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                            return response.json(); // Parse the JSON response
                        })
                        .then(data => {
                            document.getElementById('book').innerHTML = data.html;
                            // Update global variables with new data
                            if (data.data) {
                                wordsArray = data.data.words;
                                totalWords = wordsArray.length;
                                topWord = data.data.topWord;
                                pageNum = parseInt(data.data.pageNum);
                                bookId = data.data.bookId;
                                reInitDom();
                                fillContainerWithWords(topWord);
                                resolve(); // Resolve the promise after updating the DOM
                            } else {
                                console.error('Invalid or missing data in response');
                                console.log("Response data:", data);
                                reject(new Error('Invalid or missing data in response'));
                            }
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            reject(error); // Reject the promise in case of an error
                        });
                });
            }

            function reportVieportChange() {
                let url = `/viewport?top-word=${topWord}&book-id=${bookId}&page-num=${pageNum}`;
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.text();
                    })
                    .then(data => {
                        // No need to process the server's response
                    })
                    .catch(error => console.error('Error:', error));
            }

            document.body.addEventListener('htmx:configRequest', function(event) {
                // Add page and book parameters to all HTMX requests
                event.detail.parameters['page-num'] = pageNum;
                event.detail.parameters['book-id'] = bookId;
                event.detail.parameters['top-word'] = topWord;
            });

            async function handlePrevButtonClick() {
                if (topWord === 0) {
                    // Already at the beginning of the page, load the previous page
                    if (pageNum === 1) {
                        // Already at the beginning of the book, do nothing
                        return;
                    }
                    await loadPage(pageNum - 1);
                    topWord = totalWords;  // Set topWord to the end of the page to trigger a search for the beginning of the page
                }
                topWord = findViewportStart();
                fillContainerWithWords(topWord);
                reportVieportChange();
            }

            function handleNextButtonClick() {
                let lastWordIndex = getLastVisibleWord();
                if (lastWordIndex >= wordsArray.length - 1) {
                    // Last word is already visible, load the next page
                    loadPage(pageNum + 1);
                    return;
                }
                topWord = lastWordIndex + 1;
                reportVieportChange();
                fillContainerWithWords(topWord);
            }

            function reInitDom() {
                // Reattach event listener to the previous button
                let prevButton = document.getElementById('prev-button');
                if (prevButton) {
                    prevButton.removeEventListener('click', handlePrevButtonClick);
                    prevButton.addEventListener('click', handlePrevButtonClick);
                }

                // Reattach event listener to the next button
                let nextButton = document.getElementById('next-button');
                if (nextButton) {
                    nextButton.removeEventListener('click', handleNextButtonClick);
                    nextButton.addEventListener('click', handleNextButtonClick);
                }

                wordsContainer = document.getElementById('words-container');

            // window.addEventListener('resize', function() {
            //    fillContainerWithWords(topWord);
            // );
            }
            reInitDom();
            fillContainerWithWords(topWord);
        </script>

    </body>
</html>
